/**
 * HSBC API
 * A mock RESTful API for HSCB services
 *
 * Vversion: 0.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://localhost/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AppointmentBooking {
    'contactInfo': ContactInfo;
    /**
     * Additional information for the appointment
     */
    'details': string;
}

/**
 * Reference information for a booked appointment
 */
export class AppointmentInfo {
    'reference': string;
    'date': string;
}

export class CalculationResult {
    'result': number;
    'details': string;
}

/**
 * A banking calculator for a particular product function
 */
export class Calculator {
    /**
     * Unique ID of this calculator
     */
    'id': string;
    /**
     * The particular function this calculator computes
     */
    'function': string;
    /**
     * The list of named parameters to include in a CalculatorQuery to this Calculator. All parameters are numbers.
     */
    'parameters': Array<string>;
}

export class CalculatorList {
    /**
     * The product or product category this calculator belongs to
     */
    'product': string;
    'calculators': Array<Calculator>;
}

/**
 * An object containing the necessary parameters as key-value pairs for a particular product function
 */
export class CalculatorQuery {
}

export class ContactInfo {
    'firstName': string;
    'lastName': string;
    'email': string;
    'phone': string;
}

/**
 * Conversion from one currency to another
 */
export class Conversion {
    /**
     * Three letter abbreviation of the currency to sell
     */
    'from': string;
    /**
     * Three letter abbreviation of the currency to buy
     */
    'to': string;
    /**
     * Request amount to convert
     */
    'amount': number;
    /**
     * Conversion of the specified amount from the desired to target currency
     */
    'result': number;
}

export class Currency {
    /**
     * Full name of the currency
     */
    'name': string;
    /**
     * Three letter abbreviation for the currency
     */
    'code': string;
}

/**
 * Exchange rate from a base currency to target currency, including their full names
 */
export class DetailedExchangeRate {
    'from': Currency;
    'to': Currency;
    'buy': number;
    'sell': number;
    'timestamp': string;
}

/**
 * The buying and selling rates to/from a target currency, given some other currency
 */
export class ExchangeRate {
    /**
     * Three letter abbreviation of the target currency
     */
    'to': string;
    'buy': number;
    'sell': number;
}

export class ExchangeRateInfo {
    /**
     * The currency to find exchange rates for
     */
    'from': Currency;
    'rates': Array<ExchangeRate>;
}

export class ModelError {
    /**
     * Information about the error
     */
    'info': string;
}


export interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        this.authentications[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     *
     * @summary Books an appointment.
     * @param appointmentBooking
     */
    public appointmentsPost (appointmentBooking?: AppointmentBooking) : Promise<{ response: http.ClientResponse; body: AppointmentInfo;  }> {
        const localVarPath = this.basePath + '/appointments';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: appointmentBooking,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AppointmentInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of publically available calculators for a given product
     * @summary Calculator Types
     * @param product A banking product name
     */
    public bankingProductCalculateGet (product: string) : Promise<{ response: http.ClientResponse; body: CalculatorList;  }> {
        const localVarPath = this.basePath + '/banking/{product}/calculate'
                .replace('{' + 'product' + '}', String(product));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'product' is not null or undefined
        if (product === null || product === undefined) {
            throw new Error('Required parameter product was null or undefined when calling bankingProductCalculateGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CalculatorList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the result of the product function calculator given the parameters in the body
     * @summary A Calculation Result
     * @param product A banking product name
     * @param id The unique id of a product function calculator
     * @param calculatorQuery An object containing the parameters to perform this calculation
     */
    public bankingProductCalculateIdPost (product: string, id: string, calculatorQuery?: CalculatorQuery) : Promise<{ response: http.ClientResponse; body: CalculationResult;  }> {
        const localVarPath = this.basePath + '/banking/{product}/calculate/{id}'
                .replace('{' + 'product' + '}', String(product))
                .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'product' is not null or undefined
        if (product === null || product === undefined) {
            throw new Error('Required parameter product was null or undefined when calling bankingProductCalculateIdPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling bankingProductCalculateIdPost.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: calculatorQuery,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CalculationResult;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Converts a specified amount from a selling to a buying currency
     * @param from Three letter abbreviation of a supported currency to sell
     * @param to Three letter abbreviation of a supported currency to buy
     * @param amount The desired amount to exchange from selling to buying currency
     */
    public fxratesConvertGet (from: string, to: string, amount: number) : Promise<{ response: http.ClientResponse; body: Conversion;  }> {
        const localVarPath = this.basePath + '/fxrates/convert';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling fxratesConvertGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling fxratesConvertGet.');
        }

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling fxratesConvertGet.');
        }

        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (to !== undefined) {
            queryParameters['to'] = to;
        }

        if (amount !== undefined) {
            queryParameters['amount'] = amount;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Conversion;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Returns the buying and selling rates to all supported currencies from the specified one
     * @param from Three letter abbreviation of a supported currency
     */
    public fxratesFromGet (from: string) : Promise<{ response: http.ClientResponse; body: ExchangeRateInfo;  }> {
        const localVarPath = this.basePath + '/fxrates/{from}'
                .replace('{' + 'from' + '}', String(from));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling fxratesFromGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExchangeRateInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     *
     * @summary Returns the exchange rate between the base and target currencies
     * @param from
     * @param to
     */
    public fxratesFromToGet (from: string, to: string) : Promise<{ response: http.ClientResponse; body: DetailedExchangeRate;  }> {
        const localVarPath = this.basePath + '/fxrates/{from}/{to}'
                .replace('{' + 'from' + '}', String(from))
                .replace('{' + 'to' + '}', String(to));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'from' is not null or undefined
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling fxratesFromToGet.');
        }

        // verify required parameter 'to' is not null or undefined
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling fxratesFromToGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedExchangeRate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
